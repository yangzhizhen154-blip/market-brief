# -*- coding: utf-8 -*-
"""maket brief-US

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1XxGOHNI5WRs7d0r9HQkvajd-WnamhlOj
"""

!pip install yfinance feedparser pandas python-dateutil lxml

import re
from datetime import datetime, timezone, timedelta

import pandas as pd
import yfinance as yf
import feedparser
from dateutil import parser as dateparser

# ==========================
# SELECT WHICH REPORT TO RUN
# ==========================
# "US" = US markets (run before 9am)
# "AE" = Asia + Europe markets (run around 4:30pm)
MODE = "US"   # <-- change to "AE" when needed

# --------------------------
# Common config
# --------------------------
PRICE_DAYS = 7
LOOKBACK_HOURS_DEFAULT = 24

RSS_FEEDS = [
    "https://www.reutersagency.com/feed/?best-topics=business-finance&post_type=best",
    "https://feeds.bbci.co.uk/news/business/rss.xml",
    "https://www.ft.com/rss/home",
    "https://www.cnbc.com/id/100003114/device/rss/rss.html",
    "https://finance.yahoo.com/news/rssindex",
]

FX_CORE = {
    "US Dollar Index": "DX-Y.NYB",  # DXY proxy on Yahoo
    "EUR/USD": "EURUSD=X",
    "USD/JPY": "JPY=X",
    "USD/HKD": "HKD=X",
}

COMMODITIES_CORE = {
    "Gold": "GC=F",
    "Crude oil": "CL=F",
}

KEY_COMPANIES_US = {
    "Tesla": "TSLA",
    "Google": "GOOGL",
    "Apple Inc.": "AAPL",
    "NVIDIA Corporation": "NVDA",
}

BONDS_US = {
    "US 10Y": "^TNX",  # yield in %
    "US 30Y": "^TYX",  # yield in %
}

# --------------------------
# Mode-specific universe + lookback window
# --------------------------
MODE = MODE.strip().upper()
if MODE not in ("US", "AE"):
    raise ValueError("MODE must be 'US' or 'AE'")

if MODE == "US":
    TITLE = "US markets (9 a.m)"
    LOOKBACK_HOURS = 18
    EQUITIES = {
        "S&P 500": "^GSPC",
        "Nasdaq": "^IXIC",
        "Russell 2000": "^RUT",
        "VIX": "^VIX",
    }
    BONDS = BONDS_US
    FX = FX_CORE
    COMMODITIES = COMMODITIES_CORE
    KEY_COMPANIES = KEY_COMPANIES_US

else:  # AE
    TITLE = "Asian & Europe markets (4:30 p.m)"
    LOOKBACK_HOURS = 10
    EQUITIES = {
        "Nikkei 225": "^N225",
        "Hang Seng": "^HSI",
        "Shanghai Composite": "000001.SS",
        "Euro Stoxx 50": "^STOXX50E",
        "FTSE 100": "^FTSE",
    }
    BONDS = BONDS_US
    FX = FX_CORE
    COMMODITIES = COMMODITIES_CORE
    KEY_COMPANIES = {}  # optional for AE

# --------------------------
# Price helpers
# --------------------------
def fetch_last_two_closes(ticker: str):
    data = yf.download(ticker, period=f"{PRICE_DAYS}d", interval="1d", progress=False)
    if data is None or data.empty or "Close" not in data:
        return None, None
    closes = data["Close"].dropna()
    if len(closes) < 2:
        return None, None
    return float(closes.iloc[-1]), float(closes.iloc[-2])

def pct_change(last, prev):
    if last is None or prev is None or prev == 0:
        return None
    return (last - prev) / prev * 100.0

def fmt_pct(x):
    return "N/A" if x is None else f"{x:+.2f}%"

def get_block(block_dict, kind="price"):
    """
    kind:
      - "price": normal assets
      - "yield": ^TNX/^TYX: value already in percent (%). Change is output in bp.
    """
    rows = []
    for name, ticker in block_dict.items():
        last, prev = fetch_last_two_closes(ticker)
        if last is None:
            rows.append((name, None, None, ticker))
            continue

        if kind == "yield":
            level = last  # already %
            bp = (last - prev) * 100.0  # 0.01% = 1bp
            rows.append((name, level, bp, ticker))
        else:
            level = last
            chg = pct_change(last, prev)
            rows.append((name, level, chg, ticker))
    return rows

# --------------------------
# News helpers
# --------------------------
def clean_html(s: str) -> str:
    s = re.sub(r"<.*?>", " ", s or "")
    return re.sub(r"\s+", " ", s).strip()

def parse_entry_time(e):
    for k in ("published", "updated"):
        if k in e:
            try:
                dt = dateparser.parse(e[k])
                if dt.tzinfo is None:
                    dt = dt.replace(tzinfo=timezone.utc)
                return dt.astimezone(timezone.utc)
            except:
                pass
    return None

MACRO_KEYS_US = [
    "fed","fomc","powell","rates","rate cut","rate hike",
    "inflation","cpi","pce","ppi","jobs","payrolls","unemployment",
    "gdp","pmi","treasury","yield","bond",
    "tariff","sanctions","opec","oil","dollar","usd"
]
MACRO_KEYS_AE = [
    "china","pboc","yuan","rmb","cpi","ppi","pmi","stimulus","property",
    "boj","japan","ecb","europe","uk","bank of england","tariff","trade",
    "oil","gold","yield","treasury"
]

def fetch_news():
    now_utc = datetime.now(timezone.utc)
    cutoff = now_utc - timedelta(hours=LOOKBACK_HOURS)
    keys = MACRO_KEYS_US if MODE == "US" else MACRO_KEYS_AE

    rows = []
    for url in RSS_FEEDS:
        feed = feedparser.parse(url)
        src = feed.feed.get("title", url).split("|")[0].strip()
        for e in feed.entries:
            dt = parse_entry_time(e)
            if dt and dt < cutoff:
                continue
            title = (e.get("title", "") or "").strip()
            summary = clean_html(e.get("summary", "") or "")
            text = (title + " " + summary).lower()
            if any(k in text for k in keys):
                rows.append({
                    "source": src,
                    "title": title,
                    "link": (e.get("link", "") or "").strip(),
                    "published": dt.isoformat() if dt else ""
                })

    df = pd.DataFrame(rows).drop_duplicates(subset=["title","link"]).reset_index(drop=True)
    return df

def pick_macro_events(news_df, n=4):
    if news_df.empty:
        return []
    priority = ["cpi","pce","inflation","jobs","payrolls","unemployment","fed","fomc","powell","yield","treasury","rates"]
    def score(title):
        tl = title.lower()
        return sum(3 for p in priority if p in tl)
    dd = news_df.copy()
    dd["score"] = dd["title"].apply(score)
    dd = dd.sort_values(["score","published"], ascending=[False, False])
    return dd.head(n).to_dict("records")

def china_macro_items(news_df, n=6):
    if news_df.empty:
        return []
    keys = ["china","pboc","yuan","rmb","cpi","ppi","pmi","stimulus","property"]
    def is_china(title):
        t = title.lower()
        return any(k in t for k in keys)
    dd = news_df[news_df["title"].apply(is_china)]
    return dd.head(n).to_dict("records")

# --------------------------
# Interpretation engine
# --------------------------
def get_change_map(rows):
    return {name: (level, chg) for name, level, chg, _ in rows}

def build_overview(eq_rows, bond_rows, fx_rows, cmd_rows):
    eq = get_change_map(eq_rows)
    cmd = get_change_map(cmd_rows)

    main_eq = "S&P 500" if MODE == "US" else "Hang Seng"
    main_chg = eq.get(main_eq, (None, None))[1]

    us10_bp = None
    for name, level, bp, _ in bond_rows:
        if name == "US 10Y":
            us10_bp = bp

    gold_chg = cmd.get("Gold", (None, None))[1]
    oil_chg = cmd.get("Crude oil", (None, None))[1]

    if main_chg is None:
        tone = "mixed"
    elif main_chg > 0.15:
        tone = "higher"
    elif main_chg < -0.15:
        tone = "lower"
    else:
        tone = "mixed"

    if us10_bp is not None:
        if us10_bp < -2:
            yield_line = "Treasury yields declined, supporting risk sentiment."
        elif us10_bp > 2:
            yield_line = "Treasury yields rose, weighing on valuations and risk appetite."
        else:
            yield_line = "Treasury yields were little changed, leaving sentiment driven by headlines."
    else:
        yield_line = "Rate moves were muted, leaving sentiment driven by headlines."

    com_line = "Gold and crude oil traded modestly."
    if gold_chg is not None and oil_chg is not None:
        if gold_chg > 0.5 and (us10_bp is not None and us10_bp < 0):
            com_line = "Gold gained alongside lower yields, while oil was steady on demand/supply balance."
        elif oil_chg > 0.7:
            com_line = "Oil advanced on supply/demand dynamics, while gold was mixed."
        elif oil_chg < -0.7:
            com_line = "Oil eased on demand concerns, while gold was mixed."

    header = "US markets" if MODE == "US" else "Asian and European markets"
    p1 = f"{header} were {tone}. {yield_line}"
    p2 = f"The dollar was broadly stable. {com_line}"
    return p1 + "\n" + p2

def build_drivers(bond_rows, macro_items):
    us10_bp = None
    for name, level, bp, _ in bond_rows:
        if name == "US 10Y":
            us10_bp = bp

    macro_text = " ".join([m["title"].lower() for m in macro_items])

    drivers = []
    if any(k in macro_text for k in ["cpi","pce","inflation","ppi"]):
        drivers.append("inflation data")
    if any(k in macro_text for k in ["jobs","payrolls","unemployment"]):
        drivers.append("labor market signals")
    if any(k in macro_text for k in ["fed","fomc","powell","rates","rate cut","rate hike"]):
        drivers.append("Fed policy expectations")
    if any(k in macro_text for k in ["tariff","trade","sanctions"]):
        drivers.append("trade policy headlines")
    if any(k in macro_text for k in ["china","pboc","yuan","stimulus","property"]):
        drivers.append("China policy/news flow")

    driver_line = "Key drivers included " + (", ".join(drivers) if drivers else "macro headlines and positioning") + "."

    if us10_bp is None:
        interp = "Cross-asset moves suggest balanced positioning into upcoming data releases."
    else:
        if us10_bp < -2:
            interp = "Falling Treasury yields supported risk-taking and benefited rate-sensitive segments."
        elif us10_bp > 2:
            interp = "Rising Treasury yields tightened financial conditions and pressured duration-sensitive assets."
        else:
            interp = "With yields stable, markets were guided mainly by headlines and relative positioning."

    return driver_line + " " + interp

# --------------------------
# Render sections
# --------------------------
def render_key_indices(eq_rows, bond_rows, fx_rows, cmd_rows, company_rows):
    out = []
    out.append("2. Key Indices")

    out.append("Equities")
    for name, level, chg, _ in eq_rows:
        out.append(f"- {name}: {level:.2f}({fmt_pct(chg)})" if level is not None else f"- {name}: N/A")

    out.append("Bonds")
    for name, level, bp, _ in bond_rows:
        out.append(f"- {name}: {level:.4f} ({bp:+.2f}bp)" if level is not None else f"- {name}: N/A")

    out.append("FX")
    for name, level, chg, _ in fx_rows:
        out.append(f"- {name} {level:.4f}({fmt_pct(chg)})" if level is not None else f"- {name}: N/A")

    out.append("Commodities")
    for name, level, chg, _ in cmd_rows:
        out.append(f"- {name}: {level:.2f}({fmt_pct(chg)})" if level is not None else f"- {name}: N/A")

    if company_rows:
        out.append("Key companies")
        for name, level, chg, _ in company_rows:
            out.append(f"- {name}:{level:.2f}({fmt_pct(chg)})" if level is not None else f"- {name}: N/A")

    return "\n".join(out)

def render_macro_section(macro_items, extra_items=None):
    out = []
    out.append("3. Macro & Policy Events")
    if not macro_items and not extra_items:
        out.append("No major macro/policy headlines flagged in the lookback window.")
        return "\n".join(out)

    if macro_items:
        for m in macro_items:
            out.append(f"- {m['title']} [{m['source']}]")
            out.append(f"  {m['link']}")

    if extra_items:
        out.append("")
        out.append("China economic data / policy (headline scan)")
        for m in extra_items:
            out.append(f"- {m['title']} [{m['source']}]")
            out.append(f"  {m['link']}")
    return "\n".join(out)

# --------------------------
# Run pipeline
# --------------------------
eq_rows = get_block(EQUITIES, kind="price")
bond_rows = get_block(BONDS, kind="yield")  # ^TNX/^TYX are already percent
fx_rows = get_block(FX, kind="price")
cmd_rows = get_block(COMMODITIES, kind="price")
company_rows = get_block(KEY_COMPANIES, kind="price") if KEY_COMPANIES else []

news_df = fetch_news()
macro_items = pick_macro_events(news_df, n=4)
extra_china = china_macro_items(news_df, n=6) if MODE == "AE" else None

overview = build_overview(eq_rows, bond_rows, fx_rows, cmd_rows)
drivers = build_drivers(bond_rows, macro_items)
if not news_df.empty:
    sources = ", ".join(sorted(set(news_df["source"].tolist())))
else:
    sources = "(none)"

lines = []

# --------------------------
# Print in your format
# --------------------------
date_str = datetime.now().strftime("%Y/%m/%d")
lines = []

lines.append(f"Daily Market Brief – {date_str}")
lines.append(f"1. {TITLE}")
lines.append("1. Market Overview")
lines.append(overview)
lines.append("")

lines.append(render_key_indices(eq_rows, bond_rows, fx_rows, cmd_rows, company_rows))
lines.append("")

lines.append(render_macro_section(macro_items, extra_items=extra_china))
lines.append("")

lines.append("4. Market Drivers & Interpretation")
lines.append(drivers)
lines.append("")
lines.append(f"Sources: {sources}")

# 生成完整报告字符串
report_text = "\n".join(lines)

# 仍然打印到屏幕（方便你看）
print(report_text)

with open("market_brief.txt","w") as f:
    import sys
    f.write(sys.stdout.getvalue() if hasattr(sys.stdout, "getvalue") else "")

from google.colab import files
files.download("market_brief.txt")

!pip -q install google-api-python-client google-auth-httplib2 google-auth-oauthlib

from googleapiclient.discovery import build
from google.colab import auth
auth.authenticate_user()

DOC_ID = "1HnmP996GEPun9whNo7xN-zY9AIrtoQIxQLG2Nf9EPb8"

# ✅ IMPORTANT: this uses the report_text variable created by your brief generator
print("DEBUG report_text preview:\n", report_text[:200])

docs = build("docs", "v1")

doc = docs.documents().get(documentId=DOC_ID).execute()
end_index = doc["body"]["content"][-1]["endIndex"]

requests = []
if end_index > 2:
    requests.append({
        "deleteContentRange": {"range": {"startIndex": 1, "endIndex": end_index - 1}}
    })

requests.append({
    "insertText": {"location": {"index": 1}, "text": report_text}
})

docs.documents().batchUpdate(documentId=DOC_ID, body={"requests": requests}).execute()
print("✅ Google Doc updated.")